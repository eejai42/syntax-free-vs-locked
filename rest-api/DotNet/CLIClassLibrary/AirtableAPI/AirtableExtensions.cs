/*************************************************
AUTO Generated by SSoT.me - 2019
    EJ Alexandra - An airtable Tool
    DO NOT MAKE CHANGES TO THIS FILE - THEY WILL BE OVERWRITTEN
*************************************************/
using JWT.Algorithms;
using JWT.Builder;
using Newtonsoft.Json;
using System.Collections.Generic;
using Newtonsoft.Json.Serialization;
using System;
using System.Configuration;
using System.Globalization;
using System.Linq;
using System.Security.Authentication;
using System.Text;
using System.Threading.Tasks;
using System.Xml;
using System.ComponentModel;
using Newtonsoft.Json.Linq;
using AirtableDirect.CLI.Lib.DataClasses;

namespace SSoT.me.AirtableToDotNetLib
{
    /// <summary>
    /// Helper methods to interact with airtable
    /// </summary>
    public static class AirtableExtensions
    {
        //private static readonly IPluralizationApi pluralizer;
        //private static readonly CultureInfo CultureInfo;

        //static AirtableExtensions()
        //{
        //    var builder = new PluralizationApiBuilder();
        //    builder.AddEnglishProvider();

        //    pluralizer = builder.Build();
        //    CultureInfo = new CultureInfo("en-US");
        //}

        public static IEnumerable<T> ConvertTo<T>(this IEnumerable<AirtableRow> sourceItems)
            where T : class, new()
        {
            var destItems = new List<T>();
            if (!(sourceItems is null))
            {
                foreach (var sourceItem in sourceItems)
                {
                    destItems.Add(sourceItem.ConvertTo<T>());
                }
            }
            return destItems;
        }

        public abstract class MyConverter<T> : JsonConverter
        {
            public bool IsRemoteCollection(string fieldName)
            {
                var property = typeof(T).GetProperty(fieldName, System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance);
                if (property == null) return false;
                else
                {
                    return property.GetCustomAttributes(true).Any(anyAttribute => anyAttribute.GetType().Name == "RemoteIsCollectionAttribute");
                }
            }
            
            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                JToken t = JToken.FromObject(value);

                if (t.Type != JTokenType.Object)
                {
                    bool isCollection = (this.IsRemoteCollection(writer.Path));
                    
                    if (isCollection)
                    {
                        writer.WriteStartArray();
                    }
                    t.WriteTo(writer);                    
                    if (isCollection)
                    {
                        writer.WriteEndArray();
                    }
                }
                else
                {
                    JObject o = (JObject)t;
                    IList<string> propertyNames = o.Properties().Select(p => p.Name).ToList();

                    o.AddFirst(new JProperty("Keys", new JArray(propertyNames)));

                    o.WriteTo(writer);
                }
            }
        }

        public class StringConverter<T> : MyConverter<T>
        {
            public override bool CanConvert(Type objectType) { return true; }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var propertyName = reader.Value;
                if (reader.TokenType == JsonToken.StartArray)
                {
                    reader.Read();
                    var values = new List<String>();
                    while (reader.TokenType != JsonToken.EndArray)
                    {
                        values.Add(reader.Value.SafeToString());
                        reader.Read();
                    }

                    if (values.Count <= 1) return values.FirstOrDefault();
                    else if (!String.IsNullOrEmpty(propertyName.SafeToString())) throw new Exception(String.Format("Can't convert ({0}) values to a single string field {1}", String.Join(", ", values), reader.Path));
                    else return null;
                }
                else if (reader.TokenType == JsonToken.String)
                {
                    var result = reader.Value;
                    return result;
                }

                return null;
            }
        }
        
        public class IntConverter : MyConverter<Int32>
        {
            public override bool CanConvert(Type objectType) { return true; }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var propertyName = reader.Value;
                if (reader.TokenType == JsonToken.StartArray)
                {
                    reader.Read();
                    var values = new List<Int32>();
                    while (reader.TokenType != JsonToken.EndArray)
                    {
                        if (Decimal.TryParse(reader.Value.SafeToString(), NumberStyles.Float, null, out var dec)) 
                        {
                            values.Add((Int32)dec);
                        }
                        reader.Read();
                    }

                    if (values.Count <= 1) return values.FirstOrDefault();
                    else if (!String.IsNullOrEmpty(propertyName.SafeToString())) throw new Exception(String.Format("Can't convert ({0}) values to a single string field {1}", String.Join(", ", values), reader.Path));
                    else return null;
                }
                else if (reader.TokenType == JsonToken.Integer)
                {
                    if (Int32.TryParse(((Int64)reader.Value).SafeToString(), out var longValue)) return longValue;
                    else return 0;
                }
                else if (reader.TokenType == JsonToken.Float)
                {
                    if (Decimal.TryParse(reader.Value.SafeToString(), NumberStyles.Float, null, out var dec)) return (Int32)dec;
                    else return 0;
                }
                else if (reader.TokenType == JsonToken.String)
                {
                    var decValue = Decimal.TryParse(reader.Value.SafeToString(), NumberStyles.Float, null, out decimal result) ? result : 0;
                    var intValue = (Int32)(Int64)Math.Round(decValue);
                    return intValue;
                }

                return null;
            }
        }
        
        public class LongConverter : MyConverter<Int64>
        {
            public override bool CanConvert(Type objectType) { return true; }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var propertyName = reader.Value;
                if (reader.TokenType == JsonToken.StartArray)
                {
                    reader.Read();
                    var values = new List<Int64>();
                    while (reader.TokenType != JsonToken.EndArray)
                    {
                        values.Add(Int64.TryParse(reader.Value.SafeToString(), out var int64value) ? int64value : 0);
                        reader.Read();
                    }

                    if (values.Count <= 1) return values.FirstOrDefault();
                    else if (!String.IsNullOrEmpty(propertyName.SafeToString())) throw new Exception(String.Format("Can't convert ({0}) values to a single string field {1}", String.Join(", ", values), reader.Path));
                    else return null;
                }
                else if (reader.TokenType == JsonToken.Integer)
                {
                    return Int64.TryParse(reader.Value.SafeToString(), out var int64Value) ? int64Value : 0;
                }
                else if (reader.TokenType == JsonToken.String)
                {
                    if (Int64.TryParse(reader.Value.SafeToString(), out var result)) return result;
                    else return 0;
                }

                return null;
            }


        }
 
        public class LongListConverter<T> : MyConverter<T>
        {
            public override bool CanConvert(Type objectType) { return true; }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var propertyName = reader.Value;
                if (reader.TokenType == JsonToken.Integer)
                {
                    var result = reader.Value.SafeToString();
                    return new string[] { result };
                }
                else if (reader.TokenType == JsonToken.StartArray)
                {
                    reader.Read();
                    var values = new List<Int64>();
                    while (reader.TokenType != JsonToken.EndArray)
                    {
                        values.Add(Int64.TryParse(reader.Value.SafeToString(), out var int64Value) ? int64Value : 0);
                        reader.Read();
                    }

                    if (typeof(T) == typeof(Int64[])) return values.ToArray();
                    else if (typeof(T) == typeof(BindingList<Int64>)) return new BindingList<Int64>(values.ToArray());
                    else return values;
                }

                return null;
            }
        }


        public class DecimalConverter : MyConverter<Decimal>
        {
            public override bool CanConvert(Type objectType) { return true; }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var propertyName = reader.Value;
                if (reader.TokenType == JsonToken.StartArray)
                {
                    reader.Read();
                    var values = new List<Decimal>();
                    while (reader.TokenType != JsonToken.EndArray)
                    {
                        values.Add(Decimal.TryParse(reader.Value.SafeToString(), NumberStyles.Float, null, out var dec) ? dec : 0);
                        reader.Read();
                    }

                    if (values.Count <= 1) return values.FirstOrDefault();
                    else if (!String.IsNullOrEmpty(propertyName.SafeToString())) throw new Exception(String.Format("Can't convert ({0}) values to a single string field {1}", String.Join(", ", values), reader.Path));
                    else return null;
                }
                else if (reader.TokenType == JsonToken.Integer)
                {
                    var result = Decimal.TryParse(reader.Value.SafeToString(), NumberStyles.Float, null, out var dec) ? dec : 0;
                    return result;
                }
                else if (reader.TokenType == JsonToken.Float)
                {
                    var result = Decimal.TryParse(reader.Value.SafeToString(), NumberStyles.Float, null, out var dec) ? dec : 0;
                    return result;
                }
                else if (reader.TokenType == JsonToken.String)
                {
                    if (Decimal.TryParse(reader.Value.SafeToString(), NumberStyles.Float, null, out var result)) return result;
                    else return 0;
                }

                return null;
            }


        }

        public class StringListConverter<T> : MyConverter<T>
        {
            public override bool CanConvert(Type objectType) { return true; }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var propertyName = reader.Value;
                if (reader.TokenType == JsonToken.String)
                {
                    var result = reader.Value.SafeToString();
                    return new string[] { result };
                }
                else if (reader.TokenType == JsonToken.StartArray)
                {
                    reader.Read();
                    var values = new List<String>();
                    while (reader.TokenType != JsonToken.EndArray)
                    {
                        values.Add(reader.Value.SafeToString());
                        reader.Read();
                    }

                    if (typeof(T) == typeof(String[])) return values.ToArray();
                    else if (typeof(T) == typeof(BindingList<String>)) return new BindingList<String>(values.ToArray());
                    else return values;

                }


                return null;
            }
        }
        
        public class IntListConverter<T> : MyConverter<T>
        {
            public override bool CanConvert(Type objectType) { return true; }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var propertyName = reader.Value;
                if (reader.TokenType == JsonToken.Integer)
                {
                    var result = reader.Value.SafeToString();
                    return new string[] { result };
                }
                else if (reader.TokenType == JsonToken.StartArray)
                {
                    reader.Read();
                    var values = new List<Int32>();
                    while (reader.TokenType != JsonToken.EndArray)
                    {
                        values.Add((Int32)(Decimal.TryParse(reader.Value.SafeToString(), NumberStyles.Float, null, out var dec) ? dec : 0));
                        reader.Read();
                    }

                    if (typeof(T) == typeof(Int32[])) return values.ToArray();
                    else if (typeof(T) == typeof(BindingList<Int32>)) return new BindingList<Int32>(values.ToArray());
                    else return values;
                }

                return null;
            }


        }

        public class DecimalListConverter<T> : MyConverter<T>
        {
            public override bool CanConvert(Type objectType) { return true; }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var propertyName = reader.Value;
                if (reader.TokenType == JsonToken.Integer)
                {
                    var result = reader.Value.SafeToString();
                    return new string[] { result };
                }
                if (reader.TokenType == JsonToken.Float)
                {
                    var result = reader.Value.SafeToString();
                    return new string[] { result };
                }
                else if (reader.TokenType == JsonToken.StartArray)
                {
                    reader.Read();
                    var values = new List<Decimal>();
                    while (reader.TokenType != JsonToken.EndArray)
                    {
                        values.Add(Decimal.TryParse(reader.Value.SafeToString(), NumberStyles.Float, null, out var dec) ? dec : 0);
                        reader.Read();
                    }

                    if (typeof(T) == typeof(Decimal[])) return values.ToArray();
                    else if (typeof(T) == typeof(BindingList<Decimal>)) return new BindingList<Decimal>(values.ToArray());
                    else return values;
                }

                return null;
            }


        }
        
        public class BooleanConverter : MyConverter<Boolean>
        {
            public override bool CanConvert(Type objectType) { return true; }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var propertyName = reader.Value;
                if (reader.TokenType == JsonToken.StartArray)
                {
                    reader.Read();
                    var values = new List<Boolean>();
                    while (reader.TokenType != JsonToken.EndArray)
                    {
                        if (reader.Value == null) values.Add(false);
                        else values.Add(Boolean.TryParse(reader.Value.SafeToString(), out var boolValue) ? boolValue : false);
                        reader.Read();
                    }

                    if (values.Count <= 1) return values.FirstOrDefault();
                    else if (!String.IsNullOrEmpty(propertyName.SafeToString())) throw new Exception(String.Format("Can't convert ({0}) values to a single string field {1}", String.Join(", ", values), reader.Path));
                    else return null;
                }
                else if (reader.TokenType == JsonToken.Boolean)
                {
                    var result = Boolean.TryParse(reader.Value.SafeToString(), out var boolValue) ? boolValue : false;
                    return result;
                }
                else if (reader.TokenType == JsonToken.Integer)
                {
                    var result = Boolean.TryParse(reader.Value.SafeToString(), out var boolValue) ? boolValue : false;
                    return result;
                }
                else if (reader.TokenType == JsonToken.Float)
                {
                    var result = Boolean.TryParse(reader.Value.SafeToString(), out var boolValue) ? boolValue : false;
                    return result;
                }
                else if (reader.TokenType == JsonToken.String)
                {
                    return Boolean.TryParse(reader.Value.SafeToString(), out var result) ? result : false;
                }

                return null;
            }
        }
        
        public class BooleanListConverter<T> : MyConverter<T>
        {
            public override bool CanConvert(Type objectType) { return true; }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var propertyName = reader.Value;
                if (reader.TokenType == JsonToken.Integer)
                {
                    var result = reader.Value.SafeToString();
                    return new bool[] { Boolean.TryParse(result, out var boolValue) ? boolValue : false };
                }
                if (reader.TokenType == JsonToken.Float)
                {
                    var result = reader.Value.SafeToString();
                    return new bool[] { Boolean.TryParse(result, out var boolValue) ? boolValue : false };
                }
                else if (reader.TokenType == JsonToken.StartArray)
                {
                    reader.Read();
                    var values = new List<Boolean>();
                    while (reader.TokenType != JsonToken.EndArray)
                    {
                        if (reader.TokenType == JsonToken.StartObject || 
                            reader.TokenType == JsonToken.Null || 
                            reader.TokenType == JsonToken.EndObject)
                        {
                            // Ignore objects in boolean arrays
                        }
                        else
                        {
                            values.Add(Boolean.TryParse(reader.Value.SafeToString(), out var boolValue) ? boolValue : false);
                        }
                        reader.Read();
                    }

                    if (typeof(T) == typeof(Boolean[])) return values.ToArray();
                    else if (typeof(T) == typeof(BindingList<Boolean>)) return new BindingList<Boolean>(values.ToArray());
                    else return values;
                }

                return null;
            }
        }
        
        public class DateTimeConverter : MyConverter<DateTime>
        {
            public override bool CanConvert(Type objectType) { return true; }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var propertyName = reader.Value;
                if (reader.TokenType == JsonToken.StartArray)
                {
                    reader.Read();
                    var values = new List<DateTime>();
                    while (reader.TokenType != JsonToken.EndArray)
                    {
                        if (reader.Value == null) values.Add(default(DateTime));
                        else values.Add(DateTime.TryParse(reader.Value.SafeToString(), out var dateValue) ? dateValue : DateTime.MinValue);
                        reader.Read();
                    }

                    if (values.Count <= 1) return values.FirstOrDefault();
                    else if (!String.IsNullOrEmpty(propertyName.SafeToString())) throw new Exception(String.Format("Can't convert ({0}) values to a single string field {1}", String.Join(", ", values), reader.Path));
                    else return null;
                }
                else if (reader.TokenType == JsonToken.Date)
                {
                    var result = DateTime.TryParse(reader.Value.SafeToString(), out var dateValue) ? dateValue : DateTime.MinValue;
                    return result;
                }
                else if (reader.TokenType == JsonToken.String)
                {
                    if (DateTime.TryParse(reader.Value.SafeToString(), out var result)) return result;
                    else return null;
                }

                return null;
            }


        }

        
        public class DateTimeListConverter<T> : MyConverter<T>
        {
            public override bool CanConvert(Type objectType) { return true; }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                var propertyName = reader.Value;
                if (reader.TokenType == JsonToken.Integer)
                {
                    var result = reader.Value.SafeToString();
                    return new DateTime[] { DateTime.TryParse(result, out var dateValue) ? dateValue : DateTime.MinValue };
                }
                if (reader.TokenType == JsonToken.Float)
                {
                    var result = reader.Value.SafeToString();
                    return new DateTime[] { DateTime.TryParse(result, out var dateValue) ? dateValue : DateTime.MinValue };
                }
                else if (reader.TokenType == JsonToken.StartArray)
                {
                    reader.Read();
                    var values = new List<DateTime>();
                    while (reader.TokenType != JsonToken.EndArray)
                    {
                        if (reader.TokenType == JsonToken.StartObject || 
                            reader.TokenType == JsonToken.Null || 
                            reader.TokenType == JsonToken.EndObject)
                        {
                            // Ignore objects in DateTime arrays
                        }
                        else
                        {
                            values.Add(DateTime.TryParse(reader.Value.SafeToString(), out var dateValue) ? dateValue : DateTime.MinValue);
                        }
                        reader.Read();
                    }

                    if (typeof(T) == typeof(DateTime[])) return values.ToArray();
                    else if (typeof(T) == typeof(BindingList<DateTime>)) return new BindingList<DateTime>(values.ToArray());
                    else return values;
                }

                return null;
            }
        }
        
        
        class SingleOrArrayConverter<T, Y> : JsonConverter
        {
            public override bool CanConvert(Type objectType)
            {
                return (objectType == typeof(T[])) || (objectType == typeof(List<T>)) || (objectType == typeof(BindingList<T>));
            }

            public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
            {
                object result = null;
                JToken token = JToken.Load(reader);
                if (token.Type == JTokenType.Array)
                {
                    if (typeof(Y).BaseType.Name == "Array")
                    {
                        result = token.ToObject<T[]>();
                    }
                    else if (typeof(Y).BaseType.Name == "List")
                    {
                        result = token.ToObject<List<T>>();
                    }
                    else if (typeof(Y).BaseType.Name == "BindingList")
                    {
                        result = token.ToObject<BindingList<T>>();
                    }
                    else throw new Exception($"Can't process JSON collection of type {typeof(Y).BaseType.Name}");
                }
                else
                {
                    if (typeof(Y).BaseType.Name == "Array")
                    {
                        result = new T[] { token.ToObject<T>() };
                    }
                    else if (typeof(Y).BaseType.Name == "List")
                    {
                        result = new List<T> { token.ToObject<T>() };
                    }
                    else if (typeof(Y).BaseType.Name == "BindingList")
                    {
                        result = new BindingList<T> { token.ToObject<T>() };
                    }
                    else throw new Exception($"Can't process collection to type: {typeof(Y).BaseType.Name}");
                }

                return result;
            }

            public override bool CanWrite
            {
                get { return false; }
            }

            public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
            {
                throw new NotImplementedException();
            }
        }

        public class CustomContractResolver<T> : DefaultContractResolver
        {
            private static readonly JsonConverter stringConverter = new StringConverter<T>();
            private static readonly JsonConverter stringListConverterArray = new StringListConverter<String[]>();
            private static readonly JsonConverter stringListConverterList = new StringListConverter<List<String>>();
            private static readonly JsonConverter stringListConverterBindingList = new StringListConverter<BindingList<String>>();
            private static readonly JsonConverter stringListConverterEnumerable = new StringListConverter<IEnumerable<String>>();
            private static readonly JsonConverter intConverter = new IntConverter();
            private static readonly JsonConverter intListConverterArray = new IntListConverter<Int32[]>();
            private static readonly JsonConverter intListConverterList = new IntListConverter<List<Int32>>();
            private static readonly JsonConverter intListConverterBindingList = new IntListConverter<BindingList<Int32>>();
            private static readonly JsonConverter intListConverterEnumerable = new IntListConverter<IEnumerable<Int32>>();
            private static readonly JsonConverter longConverter = new LongConverter();
            private static readonly JsonConverter longListConverterArray = new LongListConverter<Int64[]>();
            private static readonly JsonConverter longListConverterList = new LongListConverter<List<Int64>>();
            private static readonly JsonConverter longListConverterBindingList = new LongListConverter<BindingList<Int64>>();
            private static readonly JsonConverter longListConverterEnumerable = new LongListConverter<IEnumerable<Int64>>();
            private static readonly JsonConverter decimalConverter = new DecimalConverter();
            private static readonly JsonConverter decimalListConverterArray = new DecimalListConverter<Decimal[]>();
            private static readonly JsonConverter decimalListConverterList = new DecimalListConverter<List<Decimal>>();
            private static readonly JsonConverter decimalListConverterBindingList = new DecimalListConverter<BindingList<Decimal>>();
            private static readonly JsonConverter decimalListConverterEnumerable = new DecimalListConverter<IEnumerable<Decimal>>();
            private static readonly JsonConverter booleanConverter = new BooleanConverter();
            private static readonly JsonConverter booleanListConverterArray = new BooleanListConverter<Boolean[]>();
            private static readonly JsonConverter booleanListConverterList = new BooleanListConverter<List<Boolean>>();
            private static readonly JsonConverter booleanListConverterBindingList = new BooleanListConverter<BindingList<Boolean>>();
            private static readonly JsonConverter booleanListConverterEnumerable = new BooleanListConverter<IEnumerable<Boolean>>();
            private static readonly JsonConverter dateTimeConverter = new DateTimeConverter();
            private static readonly JsonConverter dateTimeListConverterArray = new DateTimeListConverter<DateTime[]>();
            private static readonly JsonConverter dateTimeListConverterList = new DateTimeListConverter<List<DateTime>>();
            private static readonly JsonConverter dateTimeListConverterBindingList = new DateTimeListConverter<BindingList<DateTime>>();
            private static readonly JsonConverter dateTimeListConverterEnumerable = new DateTimeListConverter<IEnumerable<DateTime>>();
            private static readonly JsonConverter atcConverter = new SingleOrArrayConverter<AirtableAttachment, T>();
            private static readonly JsonConverter atcListConverterArray = new SingleOrArrayConverter<AirtableAttachment, AirtableAttachment[]>();
            private static readonly JsonConverter atcListConverterList = new SingleOrArrayConverter<AirtableAttachment, List<AirtableAttachment>>();
            private static readonly JsonConverter atcListConverterBindingList = new SingleOrArrayConverter<AirtableAttachment, BindingList<AirtableAttachment>>();
            private static readonly JsonConverter atcListConverterEnumerable = new SingleOrArrayConverter<AirtableAttachment, IEnumerable<AirtableAttachment>>();

            protected override JsonConverter ResolveContractConverter(Type objectType)
            {
                if (objectType == typeof(Decimal?))
                {
                    object o = 1;
                }

                if (objectType != null && (objectType.IsAssignableTo(typeof(String))))
                {
                    return stringConverter;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(Decimal))))
                {
                    return decimalConverter;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(Boolean))))
                {
                    return booleanConverter;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(Boolean?))))
                {
                    return booleanConverter;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(DateTime))))
                {
                    return dateTimeConverter;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(DateTime?))))
                {
                    return dateTimeConverter;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(Int32))))
                {
                    return intConverter;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(Int32?))))
                {
                    return intConverter;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(Int64))))
                {
                    return longConverter;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(Int64?))))
                {
                    return longConverter;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(String[]))))
                {
                    return stringListConverterArray;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(Decimal[]))))
                {
                    return decimalListConverterArray;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(Boolean[]))))
                {
                    return booleanListConverterArray;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(DateTime[]))))
                {
                    return dateTimeListConverterArray;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(Int32[]))))
                {
                    return intListConverterArray;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(Int64[]))))
                {
                    return longListConverterArray;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(List<String>))))
                {
                    return stringListConverterList;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(List<Decimal>))))
                {
                    return decimalListConverterList;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(List<Boolean>))))
                {
                    return booleanListConverterList;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(List<DateTime>))))
                {
                    return dateTimeListConverterList;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(List<Int32>))))
                {
                    return intListConverterList;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(List<Int64>))))
                {
                    return longListConverterList;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(BindingList<String>))))
                {
                    return stringListConverterBindingList;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(BindingList<Decimal>))))
                {
                    return decimalListConverterBindingList;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(BindingList<Boolean>))))
                {
                    return booleanListConverterBindingList;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(BindingList<DateTime>))))
                {
                    return dateTimeListConverterBindingList;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(BindingList<Int32>))))
                {
                    return intListConverterBindingList;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(BindingList<Int64>))))
                {
                    return longListConverterBindingList;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(IEnumerable<String>))))
                {
                    return stringListConverterEnumerable;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(IEnumerable<Decimal>))))
                {
                    return decimalListConverterEnumerable;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(IEnumerable<Boolean>))))
                {
                    return booleanListConverterEnumerable;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(IEnumerable<DateTime>))))
                {
                    return dateTimeListConverterEnumerable;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(IEnumerable<Int32>))))
                {
                    return intListConverterEnumerable;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(IEnumerable<Int64>))))
                {
                    return longListConverterEnumerable;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(AirtableAttachment))))
                {
                    return atcConverter;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(AirtableAttachment[]))))
                {
                    return atcListConverterArray;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(BindingList<AirtableAttachment>))))
                {
                    return atcListConverterBindingList;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(IEnumerable<AirtableAttachment>))))
                {
                    return atcListConverterEnumerable;
                }
                else if (objectType != null && (objectType.IsAssignableTo(typeof(List<AirtableAttachment>))))
                {
                    return atcListConverterList;
                }
                else return base.ResolveContractConverter(objectType);
            }
        }

        public static bool IsAssignableTo(this Type fromType, Type toType)
        {
            return toType.IsAssignableFrom(fromType);
        }

        public static T ConvertTo<T>(this AirtableRow sourceItem)
        {
            if (sourceItem.fields == null) return default(T);
            var itemJson = JsonConvert.SerializeObject(sourceItem.fields);
            var preProcessedJson = PreprocessJson(itemJson);
            var destItem = JsonConvert.DeserializeObject<T>(preProcessedJson, new JsonSerializerSettings()
            {
                ContractResolver = new CustomContractResolver<T>()
            });
            var pi = typeof(T).GetProperties(System.Reflection.BindingFlags.Public | System.Reflection.BindingFlags.Instance)
                             .FirstOrDefault(wherePI => String.Equals(wherePI.Name, "id", StringComparison.OrdinalIgnoreCase) || wherePI.Name.EndsWith("id", StringComparison.OrdinalIgnoreCase));
            if (!ReferenceEquals(pi, null)) pi.SetValue(destItem, sourceItem.id);
            return destItem;
        }
        
        public static string PreprocessJson(string json)
        {
            var jToken = JToken.Parse(json);
            PreprocessRecursive(jToken);
            return jToken.ToString();
        }

        private static void PreprocessRecursive(JToken token)
        {
            if (token.Type == JTokenType.Object)
            {
                var jObject = token as JObject;
                var keys = jObject.Properties().Select(p => p.Name).ToList();
                foreach (var key in keys)
                {
                    var value = jObject[key];
                    if (value.Type == JTokenType.Object && value["specialValue"]?.ToString() == "NaN")
                    {
                        jObject[key] = JToken.FromObject(0); // default value
                    }
                    else
                    {
                        PreprocessRecursive(value);
                    }
                }
            }
            else if (token.Type == JTokenType.Array)
            {
                foreach (var child in token.Children())
                {
                    PreprocessRecursive(child);
                }
            }
        }

        /// <summary>
        /// Convert an xml document into json
        /// </summary>
        /// <param name="doc">The xml document to convert</param>
        /// <returns>A json string converted by Newtonsoft</returns>
        public static String XmlToJson(this XmlDocument doc)
        {
            return JsonConvert.SerializeXmlNode(doc.DocumentElement, Newtonsoft.Json.Formatting.Indented);
        }

        /// <summary>
        /// Convert a json string into an Xml Document
        /// </summary>
        /// <param name="json"></param>
        /// <returns></returns>
        public static XmlDocument JsonToXml(this String json)
        {
            try
            {
                var serializedJson = json;
                return JsonConvert.DeserializeXmlNode(serializedJson, "", true);
            }
            catch
            {
                json = String.Format("{{ RootNode: {0} }}", json);
                return JsonConvert.DeserializeXmlNode(json, "", true);
            }
        }

        /// <summary>
        /// Turn any string or object into a string, even if it's null to start with
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static String SafeToString(this object value)
        {
            if (ReferenceEquals(value, null)) return String.Empty;
            else return value.ToString();
        }

        /// <summary>
        /// Convert a string to it's proper (title) case
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        public static String ToPropperCase(this String value)
        {
            value = value.SafeToString();
            if (value.Length <= 1) return value.ToUpper();
            else return String.Join("", value.Substring(0, 1).ToUpper(), value.Substring(1));
        }


        /// <summary>
        /// Pluralize the word provided
        /// </summary>
        /// <param name="singularText">The singulra text to pluralize</param>
        /// <returns>The pluralized version of the word provided</returns>
        public static String Pluralize(this String singularText)
        {
            if (String.IsNullOrEmpty(singularText)) return String.Empty;
            //return pluralizer.Pluralize(singlularText.SafeToString());
            if (!singularText.IsPlural()) return singularText + "s";
            else return singularText;
        }

        /// <summary>
        /// Return true if the text provided is singular
        /// </summary>
        /// <param name="singularCandidate">Singular candidate</param>
        /// <returns>Returns true if the candidate word provided is singular</returns>
        public static bool IsSingular(this String singularCandidate)
        {
            if (String.IsNullOrEmpty(singularCandidate)) return false;
            //return pluralizer.IsSingular(singularCandidate.SafeToString());
            return !singularCandidate.SafeToString().EndsWith("s", StringComparison.OrdinalIgnoreCase);
        }

        /// <summary>
        /// Returns true if the text provided is pluarl
        /// </summary>
        /// <param name="pluralCandidate">The candidate word which might be plural</param>
        /// <returns>Returns true if the candidate word provided is plural</returns>
        public static bool IsPlural(this String pluralCandidate)
        {
            return !pluralCandidate.IsSingular();
        }

        /// <summary>
        /// Singularize the word provided
        /// </summary>
        /// <param name="singlularText">The plural text to Singularize </param>
        /// <returns>The singularized version of the word provided</returns>
        public static String Singuluralize(this String pluralText)
        {
            if (String.IsNullOrEmpty(pluralText)) return String.Empty;
            //return pluralizer.Singularize(pluralText.SafeToString());
            if (pluralText.IsPlural()) return pluralText.Substring(0, pluralText.Length - 1);
            else return pluralText;
        }

        private static JwtBuilder builder
        {
            get
            {
                return new JwtBuilder()
                            .WithAlgorithm(new HMACSHA256Algorithm())
                            .WithSecret("51DA01A3-8089-439C-89FD-C7227C631AB5");
            }
        }

        static string C_SECRET { get { return AirtableAPIWrapperBase.AppSettings["JwtSecret"]; } }

        private class jwtWrapper<T>
        {
            public long exp { get; set; }
            public T user { get; set; }
        }

        public static T GetJWT<T>(this String jwt)
        {
            if (String.IsNullOrEmpty(jwt)) throw new Exception("Missing JWT in Payload.AccessToken");
            else
            {
                var decodedToken = builder
                        .MustVerifySignature()
                        .Decode(jwt);
                var apiUser = JsonConvert.DeserializeObject<jwtWrapper<T>>(decodedToken);
                var expDate = DateTimeOffset.FromUnixTimeSeconds(apiUser.exp);
                if (ReferenceEquals(apiUser, null) || (expDate < DateTime.UtcNow)) throw new AuthenticationException("Invalid jtw");
                else return apiUser.user;
            }
        }

        public static String GetJwt(this object userToken)
        {
            return builder.AddClaim("exp", DateTimeOffset.UtcNow.AddMonths(1).ToUnixTimeSeconds())
                          .AddClaim("user", userToken)
                          .Encode();
                          
        }
    }
}